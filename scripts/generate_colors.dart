import 'dart:io';

import 'package:flutter/material.dart';
import '../lib/generator.dart';
import 'package:path/path.dart' as path;

/// Generate const Color constants using FlyColorGenerator
///
/// This script uses FlyColorGenerator to generate color scales from base colors
/// and generates a file with const Color objects for IDE color previews.
///
/// To run this script:
///   flutter test test/generate_colors.dart
///   OR
///   ./scripts/generate_colors.sh
///
/// Note: This script requires Flutter SDK access, so it cannot be run with
/// plain `dart run`. Use `flutter test` instead.
void main() {
  const colors = {
    'gray': '#8d8d8d',
    'mauve': '#8e8c99',
    'slate': '#8b8d98',
    'sage': '#868e8b',
    'olive': '#898e87',
    'sand': '#8d8d86',
    'tomato': '#e54d2e',
    'red': '#e5484d',
    'ruby': '#e54666',
    'crimson': '#e93d82',
    'pink': '#d6409f',
    'plum': '#ab4aba',
    'purple': '#8e4ec6',
    'violet': '#6e56cf',
    'iris': '#5b5bd6',
    'indigo': '#3e63dd',
    'blue': '#0090ff',
    'cyan': '#00a2c7',
    'teal': '#12a594',
    'jade': '#29a383',
    'green': '#30a46c',
    'grass': '#46a758',
    'brown': '#ad7f58',
    'bronze': '#a18072',
    'gold': '#978365',
    'sky': '#7ce2fe',
    'mint': '#86ead4',
    'lime': '#bdee63',
    'yellow': '#ffe629',
    'amber': '#ffc53d',
    'orange': '#f76b15',
  };

  const grayColor = '#8d8d8d';
  const lightBackground = '#FFFFFF';
  const darkBackground = '#111111';

  print('Generating color scales using FlyColorGenerator...');

  // Generate light scales with contrast and surface
  final lightScales = <String, List<Color>>{};
  final lightContrasts = <String, Color>{};
  final lightSurfaces = <String, Color>{};
  final lightAlphaScales = <String, List<Color>>{};
  for (final entry in colors.entries) {
    final scaleName = entry.key;
    final baseColor = entry.value;
    print('  Generating light scale for $scaleName...');

    final generated = FlyColorGenerator.generate(
      appearance: 'light',
      accent: baseColor,
      gray: grayColor,
      background: lightBackground,
    );

    lightScales[scaleName] = generated.accentScale;
    lightContrasts[scaleName] = generated.accentContrast;
    lightSurfaces[scaleName] = generated.accentSurface;
    lightAlphaScales[scaleName] = generated.accentScaleAlpha;
  }

  // Generate dark scales with contrast and surface
  final darkScales = <String, List<Color>>{};
  final darkContrasts = <String, Color>{};
  final darkSurfaces = <String, Color>{};
  final darkAlphaScales = <String, List<Color>>{};
  for (final entry in colors.entries) {
    final scaleName = entry.key;
    final baseColor = entry.value;
    print('  Generating dark scale for $scaleName...');

    final generated = FlyColorGenerator.generate(
      appearance: 'dark',
      accent: baseColor,
      gray: grayColor,
      background: darkBackground,
    );

    darkScales[scaleName] = generated.accentScale;
    darkContrasts[scaleName] = generated.accentContrast;
    darkSurfaces[scaleName] = generated.accentSurface;
    darkAlphaScales[scaleName] = generated.accentScaleAlpha;
  }

  print(
    'Generated ${lightScales.length} light scales and ${darkScales.length} dark scales',
  );

  // Generate the complete fly_colors.dart file
  final output = _generateFlyColorsFile(
    lightScales,
    darkScales,
    lightContrasts,
    darkContrasts,
    lightSurfaces,
    darkSurfaces,
    lightAlphaScales,
    darkAlphaScales,
  );

  // Write to file
  final outputFile = File(
    path.join(path.current, 'lib', 'colors.dart'),
  );

  outputFile.writeAsStringSync(output);
  print('Generated: ${outputFile.path}');
}

/// Generate the complete colors.dart file with FlyColor API
String _generateFlyColorsFile(
  Map<String, List<Color>> lightScales,
  Map<String, List<Color>> darkScales,
  Map<String, Color> lightContrasts,
  Map<String, Color> darkContrasts,
  Map<String, Color> lightSurfaces,
  Map<String, Color> darkSurfaces,
  Map<String, List<Color>> lightAlphaScales,
  Map<String, List<Color>> darkAlphaScales,
) {
  final buffer = StringBuffer();

  // Header
  buffer.writeln(
    '/// This file is auto-generated by scripts/generate_colors.dart',
  );
  buffer.writeln(
    '/// Do not edit manually. Regenerate when base colors are updated.',
  );
  buffer.writeln('');
  buffer.writeln('import \'package:flutter/material.dart\';');
  buffer.writeln('');
  buffer.writeln('/// ## Usage');
  buffer.writeln('///');
  buffer.writeln('/// FlyColor provides predefined color scales for all colors:');
  buffer.writeln('///');
  buffer.writeln('/// ```dart');
  buffer.writeln('/// import \'package:flycolor/colors.dart\';');
  buffer.writeln('///');
  buffer.writeln('/// // Direct access (defaults to light mode)');
  buffer.writeln('/// FlyColor.blue9;        // Step 9 (seed/base color)');
  buffer.writeln('/// FlyColor.blue1;        // Lightest step');
  buffer.writeln('/// FlyColor.blue12;       // Darkest step');
  buffer.writeln('/// FlyColor.blueContrast; // Contrast color for text');
  buffer.writeln('/// FlyColor.blueSurface;  // Surface color');
  buffer.writeln('///');
  buffer.writeln('/// // Dark mode variants');
  buffer.writeln('/// FlyColor.blue1Dark;');
  buffer.writeln('/// FlyColor.blue9Dark;');
  buffer.writeln('///');
  buffer.writeln('/// // Explicit light/dark mode');
  buffer.writeln('/// FlyColorLight.blue1;');
  buffer.writeln('/// FlyColorDark.blue1;');
  buffer.writeln('///');
  buffer.writeln('/// // Context-aware (automatically switches based on theme)');
  buffer.writeln('/// FlyColor.of(context).blue1;');
  buffer.writeln('/// FlyColor.of(context).gray9;');
  buffer.writeln('/// ```');
  buffer.writeln('');

  // Generate FlyColorLight class
  buffer.writeln('/// Light mode colors');
  buffer.writeln('class FlyColorLight {');
  buffer.writeln('  FlyColorLight._();');
  buffer.writeln('');
  for (final entry in lightScales.entries) {
    final scaleName = entry.key;
    final colors = entry.value;
    final alphaColors = lightAlphaScales[scaleName]!;

    for (int i = 0; i < 12; i++) {
      final stepNum = i + 1;
      final color = colors[i];
      buffer.writeln(
        '  static const Color $scaleName$stepNum = Color(0x${color.value.toRadixString(16).padLeft(8, '0')});',
      );
    }

    final contrast = lightContrasts[scaleName]!;
    final surface = lightSurfaces[scaleName]!;
    buffer.writeln(
      '  static const Color ${scaleName}Contrast = Color(0x${contrast.value.toRadixString(16).padLeft(8, '0')});',
    );
    buffer.writeln(
      '  static const Color ${scaleName}Surface = Color(0x${surface.value.toRadixString(16).padLeft(8, '0')});',
    );

    // Alpha variants
    for (int i = 0; i < 12; i++) {
      final stepNum = i + 1;
      final alphaColor = alphaColors[i];
      buffer.writeln(
        '  static const Color $scaleName$stepNum${'A'} = Color(0x${alphaColor.value.toRadixString(16).padLeft(8, '0')});',
      );
    }
    buffer.writeln('');
  }
  buffer.writeln('}');
  buffer.writeln('');

  // Generate FlyColorDark class
  buffer.writeln('/// Dark mode colors');
  buffer.writeln('class FlyColorDark {');
  buffer.writeln('  FlyColorDark._();');
  buffer.writeln('');
  for (final entry in darkScales.entries) {
    final scaleName = entry.key;
    final colors = entry.value;
    final alphaColors = darkAlphaScales[scaleName]!;

    for (int i = 0; i < 12; i++) {
      final stepNum = i + 1;
      final color = colors[i];
      buffer.writeln(
        '  static const Color $scaleName$stepNum = Color(0x${color.value.toRadixString(16).padLeft(8, '0')});',
      );
    }

    final contrast = darkContrasts[scaleName]!;
    final surface = darkSurfaces[scaleName]!;
    buffer.writeln(
      '  static const Color ${scaleName}Contrast = Color(0x${contrast.value.toRadixString(16).padLeft(8, '0')});',
    );
    buffer.writeln(
      '  static const Color ${scaleName}Surface = Color(0x${surface.value.toRadixString(16).padLeft(8, '0')});',
    );

    // Alpha variants
    for (int i = 0; i < 12; i++) {
      final stepNum = i + 1;
      final alphaColor = alphaColors[i];
      buffer.writeln(
        '  static const Color $scaleName$stepNum${'A'} = Color(0x${alphaColor.value.toRadixString(16).padLeft(8, '0')});',
      );
    }
    buffer.writeln('');
  }
  buffer.writeln('}');
  buffer.writeln('');

  // Generate FlyColor class with context-aware factory and static getStep
  buffer.writeln('/// Main entry point for context-aware color access.');
  buffer.writeln('///');
  buffer.writeln('/// Provides direct access to predefined color scales and context-aware color');
  buffer.writeln('/// schemes that automatically switch between light and dark modes.');
  buffer.writeln('///');
  buffer.writeln('/// ## Usage');
  buffer.writeln('///');
  buffer.writeln('/// ```dart');
  buffer.writeln('/// import \'package:flycolor/colors.dart\';');
  buffer.writeln('///');
  buffer.writeln('/// // Direct access (defaults to light mode)');
  buffer.writeln('/// FlyColor.blue9;        // Step 9 (seed/base color)');
  buffer.writeln('/// FlyColor.blue1;        // Lightest step');
  buffer.writeln('/// FlyColor.blue12;       // Darkest step');
  buffer.writeln('/// FlyColor.blueContrast; // Contrast color for text');
  buffer.writeln('/// FlyColor.blueSurface;  // Surface color');
  buffer.writeln('///');
  buffer.writeln('/// // Dark mode variants');
  buffer.writeln('/// FlyColor.blue1Dark;');
  buffer.writeln('/// FlyColor.blue9Dark;');
  buffer.writeln('///');
  buffer.writeln('/// // Explicit light/dark mode');
  buffer.writeln('/// FlyColorLight.blue1;');
  buffer.writeln('/// FlyColorDark.blue1;');
  buffer.writeln('///');
  buffer.writeln('/// // Context-aware (automatically switches based on theme)');
  buffer.writeln('/// FlyColor.of(context).blue1;');
  buffer.writeln('/// FlyColor.of(context).gray9;');
  buffer.writeln('/// ```');
  buffer.writeln('class FlyColor {');
  buffer.writeln('  FlyColor._();');
  buffer.writeln('');
  buffer.writeln('  /// Get context-aware color scheme from BuildContext.');
  buffer.writeln('  ///');
  buffer.writeln('  /// Automatically detects the current theme brightness and returns a');
  buffer.writeln('  /// [FlyColorScheme] that provides colors appropriate for the current theme.');
  buffer.writeln('  ///');
  buffer.writeln('  /// ## Example');
  buffer.writeln('  ///');
  buffer.writeln('  /// ```dart');
  buffer.writeln('  /// // In a widget build method');
  buffer.writeln('  /// final colors = FlyColor.of(context);');
  buffer.writeln('  /// Container(color: colors.blue1);  // Automatically uses light or dark variant');
  buffer.writeln('  /// ```');
  buffer.writeln('  static FlyColorScheme of(BuildContext context) {');
  buffer.writeln('    final brightness = Theme.of(context).brightness;');
  buffer.writeln('    return FlyColorScheme(isLight: brightness == Brightness.light);');
  buffer.writeln('  }');
  buffer.writeln('');
  buffer.writeln('  /// Convenience getters for step 9 (seed/base color)');
  buffer.writeln('  /// Step 9 is the same for light and dark modes');
  for (final entry in lightScales.entries) {
    final scaleName = entry.key;
    buffer.writeln('  static const Color $scaleName = FlyColorLight.${scaleName}9;');
  }
  buffer.writeln('');
  buffer.writeln('  /// Light mode colors (default)');
  for (final entry in lightScales.entries) {
    final scaleName = entry.key;
    for (int i = 1; i <= 12; i++) {
      buffer.writeln('  static const Color ${scaleName}$i = FlyColorLight.${scaleName}$i;');
    }
    buffer.writeln('  static const Color ${scaleName}Contrast = FlyColorLight.${scaleName}Contrast;');
    buffer.writeln('  static const Color ${scaleName}Surface = FlyColorLight.${scaleName}Surface;');
    // Alpha variants (light mode)
    for (int i = 1; i <= 12; i++) {
      buffer.writeln('  static const Color ${scaleName}$i${'A'} = FlyColorLight.${scaleName}$i${'A'};');
    }
    buffer.writeln('');
  }
  buffer.writeln('  /// Dark mode colors (suffixed with Dark)');
  for (final entry in darkScales.entries) {
    final scaleName = entry.key;
    for (int i = 1; i <= 12; i++) {
      buffer.writeln('  static const Color ${scaleName}$i${'Dark'} = FlyColorDark.${scaleName}$i;');
    }
    buffer.writeln('  static const Color ${scaleName}Contrast${'Dark'} = FlyColorDark.${scaleName}Contrast;');
    buffer.writeln('  static const Color ${scaleName}Surface${'Dark'} = FlyColorDark.${scaleName}Surface;');
    // Alpha variants (dark mode)
    for (int i = 1; i <= 12; i++) {
      buffer.writeln('  static const Color ${scaleName}$i${'DarkA'} = FlyColorDark.${scaleName}$i${'A'};');
    }
    buffer.writeln('');
  }
  buffer.writeln('}');
  buffer.writeln('');

  // Generate FlyColorScheme class (context-aware)
  buffer.writeln('/// Context-aware color scheme.');
  buffer.writeln('///');
  buffer.writeln('/// Automatically switches between light and dark colors based on');
  buffer.writeln('/// the current theme context. Returned by [FlyColor.of] to provide');
  buffer.writeln('/// theme-appropriate colors.');
  buffer.writeln('///');
  buffer.writeln('/// ## Usage');
  buffer.writeln('///');
  buffer.writeln('/// ```dart');
  buffer.writeln('/// // In a widget build method');
  buffer.writeln('/// final colors = FlyColor.of(context);');
  buffer.writeln('/// Container(color: colors.blue1);  // Automatically uses light or dark variant');
  buffer.writeln('/// Text(\'Hello\', style: TextStyle(color: colors.gray12));');
  buffer.writeln('/// ```');
  buffer.writeln('class FlyColorScheme {');
  buffer.writeln('  final bool _isLight;');
  buffer.writeln('');
  buffer.writeln('  FlyColorScheme({required bool isLight}) : _isLight = isLight;');
  buffer.writeln('');

  // Direct color access
  for (final entry in lightScales.entries) {
    final scaleName = entry.key;

    for (int i = 0; i < 12; i++) {
      final stepNum = i + 1;
      buffer.writeln(
        '  Color get $scaleName$stepNum => _isLight ? FlyColorLight.$scaleName$stepNum : FlyColorDark.$scaleName$stepNum;',
      );
    }

    buffer.writeln(
      '  Color get ${scaleName}Contrast => _isLight ? FlyColorLight.${scaleName}Contrast : FlyColorDark.${scaleName}Contrast;',
    );
    buffer.writeln(
      '  Color get ${scaleName}Surface => _isLight ? FlyColorLight.${scaleName}Surface : FlyColorDark.${scaleName}Surface;',
    );

    // Alpha variants (context-aware)
    for (int i = 0; i < 12; i++) {
      final stepNum = i + 1;
      buffer.writeln(
        '  Color get $scaleName$stepNum${'A'} => _isLight ? FlyColorLight.$scaleName$stepNum${'A'} : FlyColorDark.$scaleName$stepNum${'A'};',
      );
    }
    buffer.writeln('');
  }
  buffer.writeln('}');
  buffer.writeln('');

  // Extension for hex conversion
  buffer.writeln('// Extract RGB from ARGB32 format');
  buffer.writeln('extension ColorToHex on Color {');
  buffer.writeln('  String toHex() {');
  buffer.writeln('    final argb = toARGB32();');
  buffer.writeln('    final r = ((argb >> 16) & 0xFF).toRadixString(16).padLeft(2, \'0\');');
  buffer.writeln('    final g = ((argb >> 8) & 0xFF).toRadixString(16).padLeft(2, \'0\');');
  buffer.writeln('    final b = (argb & 0xFF).toRadixString(16).padLeft(2, \'0\');');
  buffer.writeln('    return \'#\${r.toUpperCase()}\${g.toUpperCase()}\${b.toUpperCase()}\';');
  buffer.writeln('  }');
  buffer.writeln('}');

  return buffer.toString();
}
